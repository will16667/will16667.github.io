<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>è•ƒèŒ„æ™‚é˜ + To-Doï¼ˆå«åˆ†é¡åˆ†é ï¼‰</title>
<style>
:root{
  --bg: 240 10% 6%;
  --fg: 0 0% 98%;
  --fg-dim: 0 0% 80%;
  --accent: 340 82% 52%;
  --card: 240 10% 10%;
  --glass: 240 10% 14% / .5;
  --shadow: 0 0% 0% / .25;
  --radius: 20px;
  color-scheme: dark;
}
.light {
  --bg: 0 0% 98%;
  --fg: 240 10% 6%;
  --fg-dim: 240 5% 35%;
  --accent: 340 82% 52%;
  --card: 0 0% 100%;
  --glass: 0 0% 100% / .6;
  --shadow: 0 0% 0% / .08;
  color-scheme: light;
}
*{ box-sizing: border-box; }
html,body{
  height:100%;
  margin:0;
  background: hsl(var(--bg));
  color: hsl(var(--fg));
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans TC, sans-serif;
}
a{ color:hsl(var(--accent)); }
header{
  max-width:1100px;
  margin:0 auto;
  padding:24px 16px 0;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 8px;
  flex-wrap: wrap;
}
h1{
  font-size: clamp(1.4rem, 2vw, 1.8rem);
  letter-spacing:.02em;
  display:flex;
  gap:8px;
  align-items:center;
}
header .right{
  display:flex; align-items:center; gap:8px; flex-wrap:wrap;
}
.stats{
  display:flex; align-items:center; gap:8px;
  color:hsl(var(--fg-dim));
  font-size:.9rem;
}
.stats span{ display:inline-flex; align-items:center; gap:4px; }

.btn{
  border:none; border-radius:8px; padding:8px 12px; cursor:pointer;
  background:hsl(var(--card) / .6); color:hsl(var(--fg));
}
.btn.primary{ background:hsl(var(--accent)); color:#fff; }
.btn.icon{ background:transparent; padding:4px 6px; }

main{
  max-width: 1100px;
  margin: 0 auto;
  padding: 24px 16px 80px;
  display:grid;
  grid-template-columns: minmax(280px, 1fr) minmax(300px, 1fr);
  gap: 24px;
}
.card{
  background: hsla(var(--glass));
  border-radius: var(--radius);
  box-shadow: 0 20px 40px -20px hsl(var(--shadow));
  backdrop-filter: blur(18px) saturate(140%);
  -webkit-backdrop-filter: blur(18px) saturate(140%);
  border: 1px solid hsl(0 0% 100% / .06);
  padding: 24px;
}
.timer-container{
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:16px;
}
.tabs{
  display:flex;
  justify-content:center;
  gap:8px;
  margin-bottom:8px;
  flex-wrap:wrap;
}
.tabs button{
  border:none;
  padding:6px 12px;
  border-radius:999px;
  background: hsl(var(--card) / .6);
  color: hsl(var(--fg-dim));
  cursor:pointer;
  transition:.2s;
}
.tabs button.active{
  background: hsl(var(--accent));
  color:#fff;
}
.time{
  font-size: clamp(42px, 9vw, 72px);
  font-variant-numeric: tabular-nums;
  letter-spacing:.04em;
  margin-top: -14px;
}
.controls{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  justify-content:center;
}
.controls button{
  border:none;
  padding:12px 18px;
  border-radius:12px;
  background:hsl(var(--accent));
  color:#fff;
  font-weight:600;
  cursor:pointer;
  transition:.2s;
}
.controls button.secondary{
  background: hsl(var(--card) / .5);
  color: hsl(var(--fg));
}
.controls button:disabled{
  opacity:.4;
  cursor:not-allowed;
}
.progress-ring{
  width: 280px;
  height: 280px;
  border-radius:50%;
  background:
    conic-gradient(hsl(var(--accent)) var(--pct, 0%), hsl(var(--card) / .3) 0),
    radial-gradient(circle at 50% 50%, transparent 70%, hsl(var(--card) / .6) 71%);
  display:flex;
  align-items:center;
  justify-content:center;
  position:relative;
}
.settings{
  display:grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap:12px;
  margin-top: 16px;
}
.settings label{
  display:flex;
  flex-direction:column;
  gap:4px;
  font-size:.85rem;
  color:hsl(var(--fg-dim));
}
.settings input[type="number"]{
  border:none;
  border-radius:8px;
  padding:8px 10px;
  background:hsl(var(--card) / .6);
  color:hsl(var(--fg));
  width:100%;
}
.settings input[type="range"]{
  width:100%;
}
.switch{
  display:flex; align-items:center; gap:8px; margin-top:8px;
}
.todo{
  display:flex; flex-direction:column; gap:12px;
}
.todo form{
  display:flex; gap:8px; flex-wrap:wrap;
}
.todo input[type="text"]{
  flex:1;
  border:none;
  border-radius:10px;
  padding:12px 14px;
  background:hsl(var(--card) / .6);
  color: hsl(var(--fg));
}
.todo button{
  border:none;
  padding:12px 16px;
  border-radius:10px;
  background:hsl(var(--accent));
  color:#fff; font-weight:600; cursor:pointer;
}
ul.tasks{
  margin:0; padding:0; list-style:none; display:flex; flex-direction:column; gap:6px; max-height:480px; overflow:auto;
}
.tasks > li{
  background:hsl(var(--card) / .5);
  border-radius:10px;
  padding:10px 12px;
  display:flex;
  flex-direction:column;
  gap:8px;
  position:relative;
}
.tasks > li.done > .row{
  opacity:.5;
  text-decoration: line-through;
}
.tasks > li.current{
  border-left: 4px solid hsl(var(--accent));
  padding-left: 8px;
}
.row{
  display:flex;
  align-items:center;
  gap:8px;
}
.dragging{
  opacity: .5;
}
.title{
  flex:1; outline:none;
  writing-mode: horizontal-tb;
  white-space: normal;
}
.icon-btn{
  background:transparent !important;
  border:none;
  color:hsl(var(--fg-dim));
  cursor:pointer;
  border-radius:8px;
  padding:4px 6px;
}
.icon-btn:hover{
  background:hsl(var(--card) / .6) !important;
  color:hsl(var(--fg));
}
.badge{
  font-size:.75rem;
  padding:2px 6px;
  border-radius:999px;
  background:hsl(var(--card) / .5);
  margin-left:4px;
}
.pomo-badge{
  font-size:.8rem;
  margin-left:4px;
}
footer{
  text-align:center;
  color:hsl(var(--fg-dim));
  font-size:.85rem;
  margin-top:32px;
}
.modal{
  position: fixed; inset:0;
  background:hsl(0 0% 0% / .5);
  display:flex; align-items:center; justify-content:center;
  padding:16px;
  z-index:1000;
}
.modal .dialog{
  background:hsl(var(--card) / .95);
  border:1px solid hsl(0 0% 100% / .06);
  border-radius:16px; padding:24px; max-width:360px; width:100%;
  text-align:center;
  box-shadow:0 20px 40px -20px hsl(var(--shadow));
}
.modal h3{ margin-top:0; }
.modal .actions{
  display:flex; gap:10px; justify-content:center; margin-top:16px;
}
.hide{ display:none; }
.drag-handle{
  cursor:grab;
  user-select:none;
  opacity:.6;
}
.drag-handle:active{
  cursor:grabbing;
}

/* Subtasks */
ul.subtasks{
  list-style:none;
  margin: 4px 0 0 24px;
  padding:0;
  display:flex; flex-direction:column; gap:4px;
}
.sub-row{
  display:flex; align-items:center; gap:6px;
  background:hsl(var(--card) / .4);
  border-radius:8px; padding:6px 8px;
}

/* Category tabs */
.cat-tabs{
  display:flex; gap:6px; flex-wrap:wrap; margin-bottom:8px;
}
.cat-tabs button{
  border:none;
  padding:6px 10px;
  border-radius:999px;
  background:hsl(var(--card) / .5);
  color:hsl(var(--fg-dim));
  cursor:pointer; transition:.15s;
}
.cat-tabs button.active{
  background:hsl(var(--accent));
  color:#fff;
}
.cat-tabs .add{
  background:hsl(var(--card) / .2);
  color:hsl(var(--fg-dim));
}
.cat-tabs .cat-close{
  margin-left:4px;
  cursor:pointer;
  opacity:.6;
}
.cat-tabs .cat-close:hover{ opacity:1; }

/* Responsive */
@media (max-width: 1024px){
  main{ grid-template-columns: 1fr; }
}
@media (max-width: 768px){
  .progress-ring{ width: 240px; height:240px; }
}
@media (max-width: 480px){
  header{ padding-top:16px; }
  .controls button{ padding:10px 14px; }
  .time{ font-size: 56px; }
  .todo form button{ width:100%; }
}
</style>
</head>
<body>
<header>
  <h1>è•ƒèŒ„æ™‚é˜ <span style="opacity:.5;">+</span> To-Do</h1>

  <div class="right">
    <div class="stats" id="statsView">
      <span>ğŸ… ä»Šæ—¥ï¼š<strong id="statsToday">0</strong></span>
      <span>ï½œ ç´¯è¨ˆï¼š<strong id="statsTotal">0</strong></span>
    </div>

    <button class="btn" id="exportBtn">åŒ¯å‡º</button>
    <button class="btn" id="importBtn">åŒ¯å…¥</button>
    <input type="file" id="importFile" accept="application/json" hidden>

    <button id="themeToggle" class="btn icon" aria-label="åˆ‡æ›ä¸»é¡Œ">ğŸŒ“</button>
  </div>
</header>

<main>
  <section class="card" id="timerCard">
    <div class="timer-container">
      <div class="tabs" id="modeTabs">
        <button data-mode="work" class="active">å·¥ä½œ <span class="badge" id="workBadge">25</span></button>
        <button data-mode="short">çŸ­ä¼‘æ¯ <span class="badge" id="shortBadge">5</span></button>
        <button data-mode="long">é•·ä¼‘æ¯ <span class="badge" id="longBadge">15</span></button>
      </div>

      <div class="progress-ring" id="ring" style="--pct:0%;">
        <div class="time" id="time">25:00</div>
      </div>

      <div class="controls">
        <button id="startPauseBtn">é–‹å§‹</button>
        <button id="resetBtn" class="secondary">é‡ç½®</button>
      </div>

      <div class="settings">
        <label>å·¥ä½œï¼ˆåˆ†é˜ï¼‰
          <input type="number" id="workInput" min="1" value="25">
        </label>
        <label>çŸ­ä¼‘æ¯ï¼ˆåˆ†é˜ï¼‰
          <input type="number" id="shortInput" min="1" value="5">
        </label>
        <label>é•·ä¼‘æ¯ï¼ˆåˆ†é˜ï¼‰
          <input type="number" id="longInput" min="1" value="15">
        </label>
        <label>æ¯ç§’æ»´ç­”éŸ³é‡
          <input type="range" id="tickVol" min="0" max="1" step="0.01" value="0.08">
        </label>
        <label>çµæŸéˆ´éŸ³é‡
          <input type="range" id="alarmVol" min="0" max="1" step="0.01" value="0.3">
        </label>
      </div>
      <label class="switch">
        <input type="checkbox" id="tickToggle" checked>
        <span>å•Ÿç”¨æ¯ç§’æ»´ç­”è²</span>
      </label>
    </div>
  </section>

  <section class="card">
    <div class="todo">
      <h2 style="margin:0 0 8px;">To-Do List
        <span class="badge" id="countBadge">0 / 0</span>
      </h2>

      <!-- åˆ†é¡åˆ†é  -->
      <div class="cat-tabs" id="catTabs"></div>

      <form id="todoForm">
        <input type="text" id="todoInput" placeholder="è¼¸å…¥ä»»å‹™ï¼ŒEnter æ–°å¢â€¦" autocomplete="off">
        <button type="submit">æ–°å¢</button>
      </form>
      <ul class="tasks" id="tasks"></ul>
    </div>
  </section>
</main>

<div class="modal hide" id="endModal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <div class="dialog">
    <h3 id="modalTitle">æ™‚é–“åˆ°ï¼</h3>
    <p id="modalMsg">é¸æ“‡è¦å»¶é•·é‚„æ˜¯çµæŸæœ¬è¼ªã€‚</p>
    <div class="actions">
      <button id="extendBtn">å»¶é•· 5 åˆ†é˜</button>
      <button id="finishBtn" class="secondary">çµæŸ</button>
    </div>
  </div>
</div>

<footer>
  ä»¥ Web Audio API ç”¢ç”Ÿæ»´ç­”èˆ‡éŸ¿éˆ´è²ã€‚è³‡æ–™æœƒå„²å­˜åœ¨ä½ çš„ç€è¦½å™¨ï¼ˆlocalStorageï¼‰ã€‚å¯åŒ¯å‡º JSON å‚™ä»½ / è½‰ç§»ã€‚
</footer>

<script>
/* -------------------- å¯èª¿æ•´å¸¸æ•¸ -------------------- */
const AUTO_MARK_DONE_AFTER_POMO = false;

/* -------------------- State -------------------- */
const els = {
  time: document.getElementById('time'),
  ring: document.getElementById('ring'),
  startPause: document.getElementById('startPauseBtn'),
  reset: document.getElementById('resetBtn'),
  tabs: document.getElementById('modeTabs'),
  workInput: document.getElementById('workInput'),
  shortInput: document.getElementById('shortInput'),
  longInput: document.getElementById('longInput'),
  workBadge: document.getElementById('workBadge'),
  shortBadge: document.getElementById('shortBadge'),
  longBadge: document.getElementById('longBadge'),
  tickToggle: document.getElementById('tickToggle'),
  tickVol: document.getElementById('tickVol'),
  alarmVol: document.getElementById('alarmVol'),
  modal: document.getElementById('endModal'),
  extendBtn: document.getElementById('extendBtn'),
  finishBtn: document.getElementById('finishBtn'),
  themeToggle: document.getElementById('themeToggle'),
  exportBtn: document.getElementById('exportBtn'),
  importBtn: document.getElementById('importBtn'),
  importFile: document.getElementById('importFile'),
  form: document.getElementById('todoForm'),
  input: document.getElementById('todoInput'),
  tasks: document.getElementById('tasks'),
  countBadge: document.getElementById('countBadge'),
  statsToday: document.getElementById('statsToday'),
  statsTotal: document.getElementById('statsTotal'),
  catTabs: document.getElementById('catTabs'),
};

const defaultSettings = {
  work: 25,
  short: 5,
  long: 15,
  tickOn: true,
  tickVolume: 0.08,
  alarmVolume: 0.3,
  theme: 'auto'
};
let S = loadSettings();
syncSettingsUI();

let mode = 'work';
let total = S.work * 60;
let remaining = total;
let running = false;
let lastTick = null;
let intervalId = null;
let cycleCount = 0;

let audioCtx = null;
let currentSessionStart = null;

let currentTaskId = null;
let stats = loadStats();
let workLog = loadLog();
updateStatsView();

let dragState = null;

// === åˆ†é¡ï¼ˆåˆ†é ï¼‰ ===
let categories = loadCategories();
let currentCatId = loadCurrentCatId() || categories[0].id;

/* -------------------- Audio -------------------- */
function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}
function playTick() {
  if (!S.tickOn || !audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'square';
  osc.frequency.value = 1000;
  gain.gain.setValueAtTime(S.tickVolume, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.02);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.02);
}
function playAlarm() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const beeps = 3;
  for (let i = 0; i < beeps; i++) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 880;
    const startT = now + i * 0.35;
    const endT = startT + 0.25;
    gain.gain.setValueAtTime(S.alarmVolume, startT);
    gain.gain.exponentialRampToValueAtTime(0.0001, endT);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(startT);
    osc.stop(endT);
  }
}

/* -------------------- Timer logic -------------------- */
function setMode(newMode, fromAuto=false) {
  mode = newMode;
  document.querySelectorAll('.tabs button').forEach(b=>{
    b.classList.toggle('active', b.dataset.mode === mode);
  });
  const minutes = S[mode];
  total = minutes * 60;
  remaining = total;
  updateDisplay();
  updateRing();
  if (!fromAuto) {
    running = false;
    clearInterval(intervalId);
    els.startPause.textContent = 'é–‹å§‹';
  }
  document.title = `(${minutes}:00) ${titleFor(mode)} - è•ƒèŒ„æ™‚é˜`;

  if (mode === 'work' && !currentTaskId) autoPickNextTask();
}
function titleFor(mode){
  return mode === 'work' ? 'å·¥ä½œ' : (mode === 'short' ? 'çŸ­ä¼‘æ¯' : 'é•·ä¼‘æ¯');
}
function startPause() {
  initAudio();
  if (running) {
    running = false;
    clearInterval(intervalId);
    els.startPause.textContent = 'é–‹å§‹';
  } else {
    if (mode === 'work' && !currentTaskId) autoPickNextTask();
    running = true;
    els.startPause.textContent = 'æš«åœ';
    lastTick = performance.now();
    if (!currentSessionStart) currentSessionStart = Date.now();
    intervalId = setInterval(tick, 200);
  }
}
function resetTimer() {
  running = false;
  clearInterval(intervalId);
  setMode(mode);
  currentSessionStart = null;
}
function tick() {
  const now = performance.now();
  if (now - lastTick >= 1000) {
    remaining -= 1;
    lastTick = now;
    if (remaining < 0) remaining = 0;
    updateDisplay();
    updateRing();
    if (remaining > 0) playTick();
    if (remaining === 0) {
      clearInterval(intervalId);
      running = false;
      handleEnd();
    }
  }
}
function updateDisplay() {
  const m = Math.floor(remaining / 60).toString().padStart(2,'0');
  const s = (remaining % 60).toString().padStart(2,'0');
  els.time.textContent = `${m}:${s}`;
  document.title = `(${m}:${s}) ${titleFor(mode)} - è•ƒèŒ„æ™‚é˜`;
}
function updateRing() {
  const pct = (1 - (remaining / total)) * 100;
  els.ring.style.setProperty('--pct', pct + '%');
}
function handleEnd() {
  playAlarm();
  blinkTitle(true);
  showModal();
  if (mode === 'work') cycleCount++;
}
function showModal() {
  els.modal.classList.remove('hide');
}
function closeModal() {
  els.modal.classList.add('hide');
  blinkTitle(false);
}
function extendTime() {
  remaining += 5 * 60;
  total += 5 * 60;
  updateDisplay();
  updateRing();
  closeModal();
  startPause();
}
function finishCycle() {
  closeModal();

  if (mode === 'work') {
    onWorkPomodoroFinished();
    const next = (cycleCount % 4 === 0) ? 'long' : 'short';
    setMode(next, true);
  } else {
    setMode('work', true);
  }
  currentSessionStart = null;
}
let blinkTimer = null;
function blinkTitle(on) {
  if (on) {
    let flag = false;
    blinkTimer = setInterval(()=>{
      document.title = flag ? 'â° æ™‚é–“åˆ°ï¼' : 'ã€€';
      flag = !flag;
    }, 600);
  } else {
    if (blinkTimer) clearInterval(blinkTimer);
    updateDisplay();
  }
}

/* -------------------- Settings -------------------- */
function loadSettings() {
  try {
    const saved = JSON.parse(localStorage.getItem('pomodoro_settings'));
    return {...defaultSettings, ...saved};
  } catch(e){
    return {...defaultSettings};
  }
}
function saveSettings() {
  localStorage.setItem('pomodoro_settings', JSON.stringify(S));
}
function syncSettingsUI() {
  els.workInput.value = S.work;
  els.shortInput.value = S.short;
  els.longInput.value = S.long;
  els.tickToggle.checked = S.tickOn;
  els.tickVol.value = S.tickVolume;
  els.alarmVol.value = S.alarmVolume;
  updateBadges();
  applyTheme(S.theme);
}
function updateBadges(){
  els.workBadge.textContent = S.work;
  els.shortBadge.textContent = S.short;
  els.longBadge.textContent = S.long;
}
['workInput','shortInput','longInput'].forEach(id=>{
  els[id].addEventListener('change', ()=>{
    const key = id.replace('Input','');
    S[key] = Math.max(1, parseInt(els[id].value||1,10));
    updateBadges();
    saveSettings();
    if (mode === key) setMode(mode);
  });
});
els.tickToggle.addEventListener('change', ()=>{
  S.tickOn = els.tickToggle.checked;
  saveSettings();
});
els.tickVol.addEventListener('input', ()=>{
  S.tickVolume = parseFloat(els.tickVol.value);
  saveSettings();
});
els.alarmVol.addEventListener('input', ()=>{
  S.alarmVolume = parseFloat(els.alarmVol.value);
  saveSettings();
});

/* -------------------- Theme -------------------- */
function applyTheme(t){
  const root = document.documentElement;
  if (t === 'auto') {
    const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
    root.classList.toggle('light', prefersLight);
  } else {
    root.classList.toggle('light', t === 'light');
  }
}
function toggleTheme(){
  if (S.theme === 'auto') {
    const isLight = document.documentElement.classList.contains('light');
    S.theme = isLight ? 'dark' : 'light';
  } else if (S.theme === 'light') {
    S.theme = 'dark';
  } else {
    S.theme = 'auto';
  }
  applyTheme(S.theme);
  saveSettings();
  const map = {auto:'è‡ªå‹•', light:'æ·ºè‰²', dark:'æ·±è‰²'};
  els.themeToggle.textContent = S.theme === 'dark' ? 'ğŸŒ™' : (S.theme === 'light' ? 'â˜€ï¸' : 'ğŸŒ“');
  els.themeToggle.setAttribute('title', 'ä¸»é¡Œï¼š' + map[S.theme]);
}
els.themeToggle.addEventListener('click', toggleTheme);
toggleTheme();

/* -------------------- Categoriesï¼ˆåˆ†é ï¼‰ -------------------- */
function loadCategories(){
  try{
    const c = JSON.parse(localStorage.getItem('pomodoro_categories'));
    if (Array.isArray(c) && c.length) return c;
  }catch(e){}
  // é è¨­
  return [
    { id: 'inbox',  name: 'ä¸€èˆ¬' },
    { id: 'study',  name: 'å­¸ç¿’' },
    { id: 'work',   name: 'å·¥ä½œ' },
  ];
}
function saveCategories(){
  localStorage.setItem('pomodoro_categories', JSON.stringify(categories));
}
function loadCurrentCatId(){
  return localStorage.getItem('pomodoro_current_cat');
}
function saveCurrentCatId(){
  localStorage.setItem('pomodoro_current_cat', currentCatId);
}
function renderCategoryTabs(){
  const ct = els.catTabs;
  ct.innerHTML = '';
  categories.forEach(cat=>{
    const btn = document.createElement('button');
    btn.textContent = cat.name;
    btn.dataset.id = cat.id;
    btn.className = cat.id === currentCatId ? 'active' : '';
    btn.addEventListener('click', ()=>{
      currentCatId = cat.id;
      saveCurrentCatId();
      renderCategoryTabs();
      renderTodos();
    });
    // é›™æ“Šæ”¹å
    btn.addEventListener('dblclick', ()=>{
      const newName = prompt('æ–°çš„åˆ†é¡åç¨±ï¼š', cat.name);
      if (!newName) return;
      cat.name = newName.trim() || cat.name;
      saveCategories();
      renderCategoryTabs();
    });
    // Alt+Click åˆªé™¤ï¼ˆä¿ç•™è‡³å°‘ 1 å€‹ï¼‰
    btn.addEventListener('click', (e)=>{
      if (e.altKey) {
        if (!confirm(`åˆªé™¤åˆ†é¡ã€Œ${cat.name}ã€ï¼Ÿï¼ˆè©²åˆ†é¡ä¸‹çš„ä»»å‹™ä¹Ÿæœƒè¢«åˆªé™¤ï¼‰`)) return;
        if (categories.length === 1) return alert('è‡³å°‘è¦ç•™ä¸€å€‹åˆ†é¡');
        // åˆªé™¤è©²åˆ†é¡ & ä»»å‹™
        categories = categories.filter(c=>c.id!==cat.id);
        todos = todos.filter(t=>t.categoryId !== cat.id);
        if (!categories.find(c=>c.id===currentCatId)) {
          currentCatId = categories[0].id;
          saveCurrentCatId();
        }
        saveCategories(); saveTodos();
        renderCategoryTabs(); renderTodos();
      }
    });
    ct.appendChild(btn);
  });

  const addBtn = document.createElement('button');
  addBtn.className = 'add';
  addBtn.textContent = 'ï¼‹';
  addBtn.title = 'æ–°å¢åˆ†é¡';
  addBtn.addEventListener('click', ()=>{
    const name = prompt('åˆ†é¡åç¨±ï¼š');
    if (!name) return;
    const id = crypto.randomUUID();
    categories.push({ id, name: name.trim() });
    currentCatId = id;
    saveCategories();
    saveCurrentCatId();
    renderCategoryTabs();
    renderTodos();
  });
  ct.appendChild(addBtn);
}

/* -------------------- To-Doï¼ˆå«å­ä»»å‹™ & é›™å‘æ‹–æ”¾ï¼‰ -------------------- */
let todos = loadTodos();
renderCategoryTabs();
renderTodos();

function loadTodos(){
  try{
    const list = JSON.parse(localStorage.getItem('pomodoro_todos')) || [];
    // èˆŠè³‡æ–™ï¼ˆæ²’æœ‰ categoryIdï¼‰â†’ é è¨­ä¸Ÿåˆ° currentCatIdï¼ˆæˆ– inboxï¼‰
    const def = categories[0]?.id || 'inbox';
    list.forEach(t=>{
      if (!t.categoryId) t.categoryId = def;
    });
    return list;
  }catch(e){
    return [];
  }
}
function saveTodos(){
  localStorage.setItem('pomodoro_todos', JSON.stringify(todos));
}
function addTodo(title){
  if (!title.trim()) return;
  todos.push({ id: crypto.randomUUID(), title: title.trim(), done: false, pomos: 0, subtasks: [], categoryId: currentCatId });
  saveTodos();
  renderTodos();
}
function addSubtask(parentId, title){
  const t = todos.find(t=>t.id===parentId);
  if (!t || !title.trim()) return;
  t.subtasks.push({ id: crypto.randomUUID(), title: title.trim(), done: false });
  saveTodos();
  renderTodos();
}
function toggleTodo(id){
  const t = todos.find(t=>t.id===id);
  if (t){
    t.done = !t.done;
    saveTodos();
    renderTodos();
  }
}
function toggleSubtask(parentId, subId){
  const t = todos.find(t=>t.id===parentId);
  if (!t) return;
  const s = t.subtasks.find(s=>s.id===subId);
  if (s){
    s.done = !s.done;
    saveTodos();
    renderTodos();
  }
}
function deleteTodo(id){
  const wasCurrent = (currentTaskId === id);
  todos = todos.filter(t=>t.id!==id);
  saveTodos();
  if (wasCurrent) {
    currentTaskId = null;
    autoPickNextTask();
  }
  renderTodos();
}
function deleteSubtask(parentId, subId){
  const t = todos.find(t=>t.id===parentId);
  if (!t) return;
  t.subtasks = t.subtasks.filter(s=>s.id!==subId);
  saveTodos();
  renderTodos();
}
function editTodoTitle(id, newTitle){
  const t = todos.find(t=>t.id===id);
  if (t){
    t.title = newTitle.trim() || t.title;
    saveTodos();
  }
}
function editSubtaskTitle(parentId, subId, newTitle){
  const t = todos.find(t=>t.id===parentId);
  if (!t) return;
  const s = t.subtasks.find(s=>s.id===subId);
  if (s){
    s.title = newTitle.trim() || s.title;
    saveTodos();
  }
}
function changeTaskCategory(taskId, catId){
  const t = todos.find(t=>t.id===taskId);
  if (!t) return;
  t.categoryId = catId;
  saveTodos();
  renderTodos();
}
function setCurrentTask(id){
  currentTaskId = id;
  renderTodos();
}
function autoPickNextTask(){
  const next = todos.find(t=>!t.done && t.categoryId === currentCatId);
  currentTaskId = next ? next.id : null;
  renderTodos();
}
function onWorkPomodoroFinished(){
  incStats();
  const end = Date.now();
  if (currentTaskId){
    const t = todos.find(t=>t.id===currentTaskId);
    if (t){
      t.pomos = (t.pomos||0) + 1;
      if (AUTO_MARK_DONE_AFTER_POMO) t.done = true;
      saveTodos();
    }
  }
  if (currentSessionStart){
    const dur = Math.round((end - currentSessionStart)/60000);
    workLog.push({
      id: crypto.randomUUID(),
      taskId: currentTaskId,
      start: currentSessionStart,
      end,
      durationMin: dur,
      date: getTodayStr()
    });
    saveLog();
  }
  autoPickNextTask();
}

function renderTodos(){
  els.tasks.innerHTML = '';
  const frag = document.createDocumentFragment();

  const list = todos.filter(t=>t.categoryId === currentCatId);
  const doneCount = list.filter(t=>t.done).length;
  els.countBadge.textContent = `${doneCount} / ${list.length}`;

  list.forEach(t=>{
    const wrapper = document.createElement('li');
    wrapper.dataset.id = t.id;
    wrapper.classList.toggle('current', t.id === currentTaskId);
    if (t.done) wrapper.classList.add('done');

    const row = document.createElement('div');
    row.className = 'row';

    const handle = document.createElement('span');
    handle.className = 'drag-handle';
    handle.title = 'æ‹–æ›³æ’åº';
    handle.textContent = 'â ¿';
    wrapper.draggable = true;

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = t.done;
    cb.addEventListener('change',()=>toggleTodo(t.id));

    const span = document.createElement('span');
    span.className = 'title';
    span.contentEditable = true;
    span.textContent = t.title;
    span.addEventListener('blur', ()=>editTodoTitle(t.id, span.textContent));
    span.addEventListener('keydown', e=>{
      if (e.key === 'Enter') { e.preventDefault(); span.blur(); }
    });

    const pomo = document.createElement('span');
    pomo.className = 'pomo-badge';
    pomo.textContent = `ğŸ… ${t.pomos||0}`;

    // åˆ†é¡ä¸‹æ‹‰ï¼ˆç§»å‹•ä»»å‹™ï¼‰
    const catSel = document.createElement('select');
    categories.forEach(c=>{
      const opt = document.createElement('option');
      opt.value = c.id; opt.textContent = c.name;
      if (c.id === t.categoryId) opt.selected = true;
      catSel.appendChild(opt);
    });
    catSel.addEventListener('change', ()=>changeTaskCategory(t.id, catSel.value));

    const toggleSubBtn = document.createElement('button');
    toggleSubBtn.className = 'icon-btn';
    toggleSubBtn.innerHTML = 'ğŸ“‚';
    toggleSubBtn.title = 'å±•é–‹ / æ”¶èµ·å­ä»»å‹™';

    const setBtn = document.createElement('button');
    setBtn.className = 'icon-btn';
    setBtn.innerHTML = 'â–¶ï¸';
    setBtn.title = 'è¨­ç‚ºç›®å‰ä»»å‹™';
    setBtn.addEventListener('click', ()=>setCurrentTask(t.id));

    const del = document.createElement('button');
    del.className = 'icon-btn';
    del.innerHTML = 'ğŸ—‘ï¸';
    del.title = 'åˆªé™¤';
    del.addEventListener('click', ()=>deleteTodo(t.id));

    row.append(handle, cb, span, pomo, catSel, toggleSubBtn, setBtn, del);
    wrapper.appendChild(row);

    // å­ä»»å‹™å€
    const subsWrap = document.createElement('div');
    subsWrap.style.marginTop = '4px';

    const subList = document.createElement('ul');
    subList.className = 'subtasks';
    subList.dataset.parent = t.id;

    t.subtasks?.forEach(s=>{
      const li = document.createElement('li');
      li.className = 'sub-row';
      li.dataset.subId = s.id;
      li.dataset.parentId = t.id;
      li.draggable = true;

      const subHandle = document.createElement('span');
      subHandle.className = 'drag-handle';
      subHandle.textContent = 'â ¿';

      const scb = document.createElement('input');
      scb.type = 'checkbox';
      scb.checked = s.done;
      scb.addEventListener('change',()=>toggleSubtask(t.id, s.id));

      const stitle = document.createElement('span');
      stitle.className = 'title';
      stitle.contentEditable = true;
      stitle.textContent = s.title;
      stitle.addEventListener('blur', ()=>editSubtaskTitle(t.id, s.id, stitle.textContent));
      stitle.addEventListener('keydown', e=>{
        if (e.key === 'Enter') { e.preventDefault(); stitle.blur(); }
      });

      const sdel = document.createElement('button');
      sdel.className = 'icon-btn';
      sdel.innerHTML = 'ğŸ—‘ï¸';
      sdel.title = 'åˆªé™¤å­ä»»å‹™';
      sdel.addEventListener('click', ()=>deleteSubtask(t.id, s.id));

      li.addEventListener('dragstart', (e)=>{
        dragState = { type:'subtask', parentId: t.id, subId: s.id };
        li.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
      });
      li.addEventListener('dragend', ()=>{
        li.classList.remove('dragging');
        dragState = null;
      });

      li.append(subHandle, scb, stitle, sdel);
      subList.appendChild(li);
    });

    const subForm = document.createElement('form');
    subForm.style.display = 'flex';
    subForm.style.gap = '6px';
    subForm.style.marginTop = '4px';
    const subInput = document.createElement('input');
    subInput.type = 'text';
    subInput.placeholder = 'æ–°å¢å­ä»»å‹™â€¦';
    subInput.style.flex = '1';
    const subBtn = document.createElement('button');
    subBtn.type = 'submit';
    subBtn.textContent = '+';
    subForm.append(subInput, subBtn);
    subForm.addEventListener('submit', e=>{
      e.preventDefault();
      addSubtask(t.id, subInput.value);
      subInput.value = '';
    });

    subsWrap.appendChild(subList);
    subsWrap.appendChild(subForm);
    subsWrap.classList.remove('hide');
    toggleSubBtn.addEventListener('click', ()=>{
      subsWrap.classList.toggle('hide');
    });

    wrapper.appendChild(subsWrap);
    frag.appendChild(wrapper);
  });

  els.tasks.appendChild(frag);

  setupDragAndDropTasks();
  setupAllSubtasksDnD();
}

els.form.addEventListener('submit', e=>{
  e.preventDefault();
  addTodo(els.input.value);
  els.input.value = '';
});

/* -------------------- Drag & Dropï¼šä»»å‹™ -------------------- */
function setupDragAndDropTasks(){
  const list = els.tasks;
  list.querySelectorAll(':scope > li').forEach(li=>{
    li.addEventListener('dragstart', (e)=>{
      dragState = { type:'task', taskId: li.dataset.id };
      li.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });
    li.addEventListener('dragend', ()=>{
      li.classList.remove('dragging');
      if (dragState?.type === 'task') reorderTodosByTaskDOM();
      dragState = null;
    });
  });

  list.addEventListener('dragover', e=>{
    const dragging = list.querySelector(':scope > li.dragging');
    if (!dragging) return;
    if (dragState?.type !== 'task') return;
    e.preventDefault();
    const after = getDragAfterElement(list, e.clientY);
    if (after == null) list.appendChild(dragging);
    else list.insertBefore(dragging, after);
  });
}
function getDragAfterElement(container, y){
  const els = [...container.querySelectorAll(':scope > li:not(.dragging)')];
  return els.reduce((closest, child)=>{
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset){
      return { offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}
function reorderTodosByTaskDOM(){
  const order = Array.from(els.tasks.children).map(li=>li.dataset.id);
  const map = new Map(todos.map(t=>[t.id, t]));
  const filtered = todos.filter(t=>t.categoryId === currentCatId);
  const others = todos.filter(t=>t.categoryId !== currentCatId);
  const reordered = order.map(id=>map.get(id));
  todos = [...reordered, ...others];
  saveTodos();
  renderTodos();
}

/* -------------------- Drag & Dropï¼šå­ä»»å‹™ï¼ˆè·¨ä»»å‹™ & å‡ç´š/é™ç´šï¼‰ -------------------- */
function setupAllSubtasksDnD(){
  const lists = els.tasks.querySelectorAll('ul.subtasks');
  lists.forEach(list=>{
    const targetParentId = list.dataset.parent;

    list.addEventListener('dragover', e=>{
      if (!dragState) return;
      if (dragState.type === 'subtask' || dragState.type === 'task') {
        e.preventDefault();
        const after = getDragAfterElementSub(list, e.clientY);
        const dragging = list.querySelector('.dragging');
        if (dragging && dragging.closest('ul.subtasks') === list) {
          if (after == null) list.appendChild(dragging);
          else list.insertBefore(dragging, after);
        }
      }
    });

    list.addEventListener('drop', e=>{
      if (!dragState) return;
      const after = getDragAfterElementSub(list, e.clientY);
      const insertIndex = calcInsertIndexInSubList(list, after);

      if (dragState.type === 'subtask') {
        moveSubtaskToAnotherParent(dragState.parentId, targetParentId, dragState.subId, insertIndex);
      } else if (dragState.type === 'task') {
        convertTaskToSubtask(dragState.taskId, targetParentId, insertIndex);
      }
      dragState = null;
    });
  });

  enableOuterDropForSubtasks();
}
function calcInsertIndexInSubList(list, afterElement){
  const ids = Array.from(list.children).map(li=>li.dataset.subId);
  if (!afterElement) return ids.length;
  const idx = ids.indexOf(afterElement?.dataset.subId);
  return Math.max(idx, 0);
}
function getDragAfterElementSub(container, y){
  const els = [...container.querySelectorAll('li.sub-row:not(.dragging)')];
  return els.reduce((closest, child)=>{
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset){
      return { offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}
function reorderSubtasksByDOM(parentId, listEl){
  const t = todos.find(t=>t.id===parentId);
  if (!t) return;
  const order = Array.from(listEl.children).map(li=>li.dataset.subId);
  const map = new Map(t.subtasks.map(s=>[s.id, s]));
  t.subtasks = order.map(id=>map.get(id));
  saveTodos();
  renderTodos();
}
function enableOuterDropForSubtasks(){
  const outer = els.tasks;

  outer.addEventListener('dragover', (e)=>{
    if (dragState?.type === 'subtask') {
      e.preventDefault();
    }
  });

  outer.addEventListener('drop', (e)=>{
    if (dragState?.type === 'subtask') {
      const after = getDragAfterElement(outer, e.clientY);
      const ids = Array.from(outer.children).map(li=>li.dataset.id);
      let insertIndex = ids.length;
      if (after) {
        const idx = ids.indexOf(after.dataset.id);
        insertIndex = Math.max(idx, 0);
      }
      convertSubtaskToTask(dragState.parentId, dragState.subId, insertIndex);
      dragState = null;
    }
  });
}
function convertSubtaskToTask(parentId, subId, insertIndex){
  const p = todos.find(t=>t.id===parentId);
  if (!p) return;
  const i = p.subtasks.findIndex(s=>s.id===subId);
  if (i === -1) return;

  const s = p.subtasks.splice(i,1)[0];
  const newTask = {
    id: s.id,
    title: s.title,
    done: s.done || false,
    pomos: 0,
    subtasks: [],
    categoryId: currentCatId   // å‡ç´šå¾Œæ”¾åˆ°ç›®å‰åˆ†é¡
  };

  const list = todos.filter(t=>t.categoryId === currentCatId);
  const others = todos.filter(t=>t.categoryId !== currentCatId);
  if (insertIndex >= list.length) list.push(newTask);
  else list.splice(insertIndex, 0, newTask);
  todos = [...list, ...others];

  saveTodos();
  renderTodos();
}
function convertTaskToSubtask(taskId, targetParentId, insertIndex){
  const taskIdx = todos.findIndex(t=>t.id===taskId);
  const parent = todos.find(t=>t.id===targetParentId);
  if (taskIdx === -1 || !parent) return;

  const t = todos.splice(taskIdx,1)[0];
  const newSub = { id: t.id, title: t.title, done: t.done || false };
  const subs = parent.subtasks || (parent.subtasks = []);
  if (insertIndex >= subs.length) subs.push(newSub);
  else subs.splice(insertIndex, 0, newSub);

  if (currentTaskId === t.id) currentTaskId = null;

  saveTodos();
  renderTodos();
}
function moveSubtaskToAnotherParent(fromParentId, toParentId, subId, insertIndex){
  if (fromParentId === toParentId){
    const list = document.querySelector(`ul.subtasks[data-parent="${fromParentId}"]`);
    reorderSubtasksByDOM(fromParentId, list);
    return;
  }
  const from = todos.find(t=>t.id===fromParentId);
  const to   = todos.find(t=>t.id===toParentId);
  if (!from || !to) return;
  const idx = from.subtasks.findIndex(s=>s.id===subId);
  if (idx === -1) return;

  const s = from.subtasks.splice(idx,1)[0];
  const subs = to.subtasks || (to.subtasks = []);
  if (insertIndex >= subs.length) subs.push(s);
  else subs.splice(insertIndex, 0, s);

  saveTodos();
  renderTodos();
}

/* -------------------- Stats & WorkLog -------------------- */
function loadStats(){
  const today = getTodayStr();
  try{
    const s = JSON.parse(localStorage.getItem('pomodoro_stats')) || {};
    if (s.lastDate !== today){
      s.todayCount = 0;
      s.lastDate = today;
    }
    if (typeof s.totalCount !== 'number') s.totalCount = 0;
    if (typeof s.todayCount !== 'number') s.todayCount = 0;
    return s;
  }catch(e){
    return { todayCount:0, totalCount:0, lastDate: getTodayStr() };
  }
}
function saveStats(){
  localStorage.setItem('pomodoro_stats', JSON.stringify(stats));
}
function getTodayStr(){
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const day = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}
function incStats(){
  const today = getTodayStr();
  if (stats.lastDate !== today){
    stats.todayCount = 0;
    stats.lastDate = today;
  }
  stats.todayCount += 1;
  stats.totalCount += 1;
  saveStats();
  updateStatsView();
}
function updateStatsView(){
  els.statsToday.textContent = stats.todayCount || 0;
  els.statsTotal.textContent = stats.totalCount || 0;
}
function loadLog(){
  try{
    return JSON.parse(localStorage.getItem('pomodoro_log')) || [];
  }catch(e){
    return [];
  }
}
function saveLog(){
  localStorage.setItem('pomodoro_log', JSON.stringify(workLog));
}

/* -------------------- Export / Import -------------------- */
els.exportBtn.addEventListener('click', ()=>{
  const data = {
    version: 3,
    exportedAt: new Date().toISOString(),
    settings: S,
    stats,
    todos,
    workLog,
    categories,
    currentCatId
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const d = new Date();
  const fname = `pomodoro-export-${d.getFullYear()}${String(d.getMonth()+1).padStart(2,'0')}${String(d.getDate()).padStart(2,'0')}.json`;
  a.href = url;
  a.download = fname;
  a.click();
  URL.revokeObjectURL(url);
});

els.importBtn.addEventListener('click', ()=>els.importFile.click());
els.importFile.addEventListener('change', async (e)=>{
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    const text = await file.text();
    const obj = JSON.parse(text);
    if (!confirm('ç¢ºå®šè¦ä»¥åŒ¯å…¥æª”è¦†è“‹ç›®å‰çš„è¨­å®š / ä»»å‹™ / çµ±è¨ˆ / ç´€éŒ„ / åˆ†é¡ï¼Ÿ')) return;

    if (obj.settings) { S = {...defaultSettings, ...obj.settings}; saveSettings(); syncSettingsUI(); }
    if (obj.stats) { stats = obj.stats; saveStats(); updateStatsView(); }
    if (obj.todos) { todos = obj.todos; saveTodos(); }
    if (obj.workLog) { workLog = obj.workLog; saveLog(); }
    if (obj.categories) { categories = obj.categories; saveCategories(); }
    if (obj.currentCatId) { currentCatId = obj.currentCatId; saveCurrentCatId(); }

    renderCategoryTabs();
    currentTaskId = null;
    autoPickNextTask();
    setMode('work');
    alert('åŒ¯å…¥å®Œæˆï¼');
  }catch(err){
    alert('åŒ¯å…¥å¤±æ•—ï¼š' + err.message);
  }finally{
    e.target.value = '';
  }
});

/* -------------------- Events -------------------- */
els.startPause.addEventListener('click', startPause);
els.reset.addEventListener('click', resetTimer);
els.tabs.addEventListener('click', e=>{
  const btn = e.target.closest('button[data-mode]');
  if (!btn) return;
  setMode(btn.dataset.mode);
});
els.extendBtn.addEventListener('click', extendTime);
els.finishBtn.addEventListener('click', finishCycle);
els.modal.addEventListener('click', e=>{
  if (e.target === els.modal) closeModal();
});

/* åˆå§‹æ¨¡å¼ */
setMode('work');
</script>
</body>
</html>